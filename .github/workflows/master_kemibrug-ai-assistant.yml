name: Build and deploy dotnet core app to Azure Function App - kemibrug-ai-assistant

on:
  push:
    branches: [ master ]
  workflow_dispatch:

env:
  AZURE_FUNCTIONAPP_PACKAGE_PATH: "."
  DOTNET_VERSION: "8.0.x"

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: "Checkout"
        uses: actions/checkout@v4

      - name: "Setup .NET"
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: "${{ env.DOTNET_VERSION }}"

      # --- BASIC ENV CHECKS ---
      - name: "Sanity check secrets (lengths only)"
        shell: bash
        run: |
          set -e
          showlen () { v="$1"; printf "%s=%s\n" "$2" "$( [ -n "$v" ] && echo ${#v} || echo 0 )"; }
          showlen "${{ secrets.AZURE_DEVOPS_ORG_URL }}" "AZURE_DEVOPS_ORG_URL_len"
          showlen "${{ secrets.AZUREDEVOPSPROJECT }}"   "AZUREDEVOPSPROJECT_len"
          showlen "${{ secrets.AZURE_DEVOPS_PAT }}"     "AZURE_DEVOPS_PAT_len"
          showlen "${{ secrets.AZUREDEVOPSREPOSITORYNAME }}" "AZUREDEVOPSREPOSITORYNAME_len"
          # Quick DNS reachability
          echo "Resolving dev.azure.com..."
          getent hosts dev.azure.com || true

      # --- RESOLVE projectId and repoId safely ---
      - name: "Resolve Azure DevOps project and repository IDs"
        id: resolve_ids
        shell: bash
        env:
          ORG_URL:   ${{ secrets.AZURE_DEVOPS_ORG_URL }}
          PROJ_NAME: ${{ secrets.AZUREDEVOPSPROJECT }}
          REPO_HINT: ${{ secrets.AZUREDEVOPSREPOSITORYNAME }}
          PAT:       ${{ secrets.AZURE_DEVOPS_PAT }}
        run: |
          set -euo pipefail
          sudo apt-get update -y && sudo apt-get install -y jq python3

          # Normalize ORG_URL (strip trailing slash)
          ORG_URL="${ORG_URL%/}"

          # 1) Fetch all projects to resolve projectId by name
          PROJ_URL="${ORG_URL}/_apis/projects?api-version=7.1-preview.1"
          echo "GET $PROJ_URL"
          P_BODY=$(mktemp)
          P_STATUS=$(curl -sS -L --fail-with-body -u :$PAT -w "%{http_code}" -o "$P_BODY" "$PROJ_URL" || true)
          echo "Projects HTTP status: $P_STATUS"
          if [ "$P_STATUS" != "200" ]; then
            echo "---- projects body (first 400 bytes) ----"
            head -c 400 "$P_BODY" || true; echo
            echo "::error::Failed to list projects. Check ORG_URL and PAT scope (Code: Read)."
            exit 3
          fi
          if ! jq -e . >/dev/null 2>&1 < "$P_BODY"; then
            echo "::error::Projects response not JSON"
            head -c 400 "$P_BODY" || true
            exit 3
          fi

          # Try exact name match
          PROJECT_ID=$(jq -r --arg n "$PROJ_NAME" '.value[] | select(.name==$n) | .id' < "$P_BODY")
          if [ -z "$PROJECT_ID" ] || [ "$PROJECT_ID" = "null" ]; then
            echo "::warning::Exact project name not found. Available projects:"
            jq -r '.value[].name' < "$P_BODY" | sed 's/^/  - /'
            echo "::error::Project name mismatch: '$PROJ_NAME'"
            exit 3
          fi
          echo "Resolved projectId: $PROJECT_ID"
          echo "RESOLVED_PROJECT_ID=$PROJECT_ID" >> "$GITHUB_ENV"

          # 2) Resolve repository ID
          # If REPO_HINT looks like a GUID, assume it's already the ID
          if [[ "$REPO_HINT" =~ ^[0-9a-fA-F-]{36}$ ]]; then
            REPO_ID="$REPO_HINT"
            echo "Using provided repository ID: $REPO_ID"
          else
            R_URL="${ORG_URL}/${PROJECT_ID}/_apis/git/repositories?api-version=7.1-preview.1"
            echo "GET $R_URL"
            R_BODY=$(mktemp)
            R_STATUS=$(curl -sS -L --fail-with-body -u :$PAT -w "%{http_code}" -o "$R_BODY" "$R_URL" || true)
            echo "Repos HTTP status: $R_STATUS"
            if [ "$R_STATUS" != "200" ]; then
              echo "---- repos body (first 400 bytes) ----"
              head -c 400 "$R_BODY" || true; echo
              echo "::error::Failed to list repositories."
              exit 3
            fi
            if ! jq -e . >/dev/null 2>&1 < "$R_BODY"; then
              echo "::error::Repos response not JSON"
              head -c 400 "$R_BODY" || true
              exit 3
            fi
            # match by name (case-sensitive)
            REPO_ID=$(jq -r --arg n "$REPO_HINT" '.value[] | select(.name==$n) | .id' < "$R_BODY")
            if [ -z "$REPO_ID" ] || [ "$REPO_ID" = "null" ]; then
              echo "::warning::Exact repo name not found. Available repos:"
              jq -r '.value[] | "  - \(.name)  (\(.id))"' < "$R_BODY"
              echo "::error::Repository name mismatch: '$REPO_HINT'"
              exit 3
            fi
            echo "Resolved repoId: $REPO_ID"
          fi
          echo "RESOLVED_REPO_ID=$REPO_ID" >> "$GITHUB_ENV"

      # --- OPTIONAL: list a few paths for confirmation ---
      - name: "List a few repo paths under / and /src"
        shell: bash
        env:
          ORG_URL: ${{ secrets.AZURE_DEVOPS_ORG_URL }}
          PAT:     ${{ secrets.AZURE_DEVOPS_PAT }}
        run: |
          set -e
          sudo apt-get update -y && sudo apt-get install -y jq
          for scope in "/" "/src"; do
            URL="${ORG_URL%/}/${RESOLVED_PROJECT_ID}/_apis/git/repositories/${RESOLVED_REPO_ID}/items?scopePath=${scope}&recursionLevel=Full&\$top=2000&api-version=7.1-preview.1"
            echo "GET $URL"
            BODY=$(mktemp)
            STATUS=$(curl -sS -L --fail-with-body -u :$PAT -w "%{http_code}" -o "$BODY" "$URL" || true)
            echo "HTTP status: $STATUS"
            if [ "$STATUS" = "200" ] && jq -e . >/dev/null 2>&1 < "$BODY"; then
              jq -r '.value[]?.path' < "$BODY" | head -n 100
            else
              echo "---- body (first 400 bytes) ----"
              head -c 400 "$BODY" || true; echo
            fi
          done

      # --- FETCH README files and build docs.json ---
      - name: "Fetch READMEs and build docs.json"
        shell: bash
        env:
          ORG_URL: ${{ secrets.AZURE_DEVOPS_ORG_URL }}
          PAT:     ${{ secrets.AZURE_DEVOPS_PAT }}
        run: |
          set -e
          sudo apt-get update -y && sudo apt-get install -y jq python3

          urlencode() {
            python3 - <<'PY'
            import sys, urllib.parse
            print(urllib.parse.quote(sys.stdin.read().strip(), safe=""))
            PY
          }

          # Adjust these if your paths differ
          declare -A FILES
          FILES["/src/KemibrugV2.Application/README.md"]="Application"
          FILES["/src/KemibrugV2.Core/README.md"]="Core"
          FILES["/src/KemibrugV2.Infrastructure/README.md"]="Infrastructure"
          FILES["/src/KemibrugV2.WebApiServer/README.md"]="WebApiServer"

          PROJECT="KemibrugV2"

          fetch_file() {
            local raw="$1"
            local enc; enc=$(printf "%s" "$raw" | urlencode)
            local url="${ORG_URL%/}/${RESOLVED_PROJECT_ID}/_apis/git/repositories/${RESOLVED_REPO_ID}/items?path=%2F${enc#%2F}&includeContent=true&api-version=7.1-preview.1"
            local tmp; tmp=$(mktemp)
            local status
            status=$(curl -sS -L --fail-with-body -u :$PAT -w "%{http_code}" -o "$tmp" "$url" || true)
            echo "$status" "$tmp"
          }

          echo "[" > docs.json
          first=1
          ok=0
          fail=0

          for path in "${!FILES[@]}"; do
            layer="${FILES[$path]}"
            read -r status tmp < <(fetch_file "$path")

            if [ "$status" != "200" ]; then
              echo "::warning::HTTP $status for $path"
              echo "---- body begin ----"
              head -c 400 "$tmp" || true; echo
              echo "---- body end ----"
              rm -f "$tmp"
              fail=$((fail+1))
              continue
            fi

            if ! jq -e . >/dev/null 2>&1 < "$tmp"; then
              echo "::warning::Non-JSON for $path"; head -c 400 "$tmp" || true; echo
              rm -f "$tmp"; fail=$((fail+1)); continue
            fi

            content=$(jq -r '.content // empty' < "$tmp" || true)
            rm -f "$tmp"

            if [ -z "$content" ]; then
              echo "::warning::No content for $path"; fail=$((fail+1)); continue
            fi

            id=$(echo "$path" | sed 's/[^a-zA-Z0-9._-]/_/g')
            entry=$(jq -n \
              --arg id "$id" \
              --arg content "$content" \
              --arg path "$path" \
              --arg layer "$layer" \
              --arg project "$PROJECT" \
              '{ "@search.action":"mergeOrUpload", id:$id, content:$content, path:$path, layer:$layer, project:$project }')

            if [ $first -eq 0 ]; then echo "," >> docs.json; fi
            echo "$entry" >> docs.json
            first=0
            ok=$((ok+1))
            echo "OK: added $path"
          done

          echo "]" >> docs.json
          echo "SUMMARY ok=$ok fail=$fail"
          jq '.[].id' docs.json || true

          if [ $ok -eq 0 ]; then
            echo "::error::No README files added to docs.json; fix IDs/paths/PAT."
            exit 2
          fi

      - name: "Upload docs.json artifact (debug)"
        uses: actions/upload-artifact@v4
        with:
          name: docs-json
          path: docs.json

      - name: "Push docs to Azure AI Search"
        shell: bash
        env:
          SEARCH_ENDPOINT: ${{ secrets.AZURE_SEARCH_ENDPOINT }}
          SEARCH_INDEX:    ${{ secrets.AZURE_SEARCH_INDEX }}
          SEARCH_KEY:      ${{ secrets.AZURE_SEARCH_ADMIN_KEY }}
        run: |
          set -e
          curl -sS -L --fail-with-body -X POST \
            -H "Content-Type: application/json" \
            -H "api-key: ${SEARCH_KEY}" \
            --data @docs.json \
            "${SEARCH_ENDPOINT}/indexes/${SEARCH_INDEX}/docs/index?api-version=2023-11-01"
          echo "Uploaded README docs to Azure AI Search."

      # --- BUILD & DEPLOY FUNCTIONS ---
      - name: "Build"
        shell: pwsh
        run: |
          pushd "./${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}"
          dotnet build --configuration Release --output ./output
          popd

      - name: "Login to Azure"
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZUREAPPSERVICE_CLIENTID_CC61583FBBEC4600B796FAECBE66F119 }}
          tenant-id: ${{ secrets.AZUREAPPSERVICE_TENANTID_4FAB11EB01304BE09563B7410BD1E837 }}
          subscription-id: ${{ secrets.AZUREAPPSERVICE_SUBSCRIPTIONID_BE4AA3B5668B4EFD94873CB496000E0A }}

      - name: "Configure app settings"
        uses: azure/CLI@v1
        with:
          inlineScript: |
            az functionapp config appsettings set \
              --name kemibrug-ai-assistant \
              --resource-group rg-diplomprojekt-ai \
              --settings \
                AzureDevOpsPAT='${{ secrets.AZURE_DEVOPS_PAT }}' \
                AzureDevOpsOrgUrl='${{ secrets.AZURE_DEVOPS_ORG_URL }}' \
                AzureDevOpsProject='${{ secrets.AZUREDEVOPSPROJECT }}' \
                AzureDevOpsRepositoryName='${{ secrets.AZUREDEVOPSREPOSITORYNAME }}' \
                AzureOpenAIEndpoint='${{ secrets.AZURE_OPENAI_ENDPOINT }}' \
                AzureOpenAIApiKey='${{ secrets.AZURE_OPENAI_APIKEY }}' \
                AzureSearchEndpoint='${{ secrets.AZURE_SEARCH_ENDPOINT }}' \
                AzureSearchIndex='${{ secrets.AZURE_SEARCH_INDEX }}' \
                AzureSearchApiKey='${{ secrets.AZURE_SEARCH_ADMIN_KEY }}' \
                AnalysisSystemPromptV2='${{ secrets.ANALYSIS_SYSTEM_PROMPT_V2 }}'

      - name: "Deploy to Azure Functions"
        uses: Azure/functions-action@v1
        with:
          app-name: "kemibrug-ai-assistant"
          slot-name: "Production"
          package: "${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}/output"


