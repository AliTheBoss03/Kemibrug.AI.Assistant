name: Build and deploy dotnet core app to Azure Function App - kemibrug-ai-assistant

on:
  push:
    branches: [ master ]
  workflow_dispatch:

env:
  AZURE_FUNCTIONAPP_PACKAGE_PATH: '.'
  DOTNET_VERSION: '8.0.x'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET ${{ env.DOTNET_VERSION }}
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      # =========================
      # Build docs.json (plain text "content")
      # =========================
      - name: Build docs.json (plain text content)
        shell: bash
        env:
          AZDO_ORG_URL:  ${{ secrets.AZURE_DEVOPS_ORG_URL }}      # e.g. https://dev.azure.com/Custom-Web-Solutions
          AZDO_PROJECT:  ${{ secrets.AZUREDEVOPSPROJECT }}        # exact project name
          AZDO_REPO:     ${{ secrets.AZUREDEVOPSREPOSITORYNAME }} # repo NAME or GUID (GUID safest)
          AZDO_PAT:      ${{ secrets.AZURE_DEVOPS_PAT }}
        run: |
          set -euo pipefail

          sudo apt-get update -y >/dev/null
          sudo apt-get install -y jq >/dev/null

          urlencode() {
            python3 - <<'PY'
            import sys, urllib.parse
            print(urllib.parse.quote(sys.stdin.read().strip(), safe="/._-"))
            PY
          }

          # --- Map of README paths -> layer name ---
          declare -A FILES
          FILES["/src/KemibrugV2.Application/README.md"]="Application"
          FILES["/src/KemibrugV2.Core/README.md"]="Core"
          FILES["/src/KemibrugV2.Infrastructure/README.md"]="Infrastructure"
          FILES["/src/KemibrugV2.WebApiServer/README.md"]="WebApiServer"

          PROJECT="KemibrugV2"

          # Start docs.json
          echo '{ "value": [] }' > docs.json

          ok=0; fail=0
          for path in "${!FILES[@]}"; do
            layer="${FILES[$path]}"
            enc_path=$(printf "%s" "$path" | urlencode)

            # Raw file content (download=true) from a specific branch (master). Change if needed.
            URL="${AZDO_ORG_URL}/${AZDO_PROJECT}/_apis/git/repositories/${AZDO_REPO}/items?path=${enc_path}&download=true&versionDescriptor.version=master&api-version=7.1-preview.1"

            echo "GET $URL"
            http_code=$(curl -sS -u ":${AZDO_PAT}" -w "%{http_code}" -o _file.tmp "$URL" || true)
            echo "HTTP $http_code"

            if [ "$http_code" != "200" ]; then
              echo "WARN: Could not fetch $path (HTTP $http_code)"
              rm -f _file.tmp
              fail=$((fail+1))
              continue
            fi

            # JSON-escape raw content
            content_json=$(jq -Rs . < _file.tmp)
            rm -f _file.tmp

            # Stable id from path
            id=$(echo "$path" | sed 's/[^a-zA-Z0-9._-]/_/g')

            # Append to docs.json.value[]
            tmp=$(mktemp)
            jq --arg id "$id" \
               --arg path "$path" \
               --arg layer "$layer" \
               --arg project "$PROJECT" \
               --argjson content "$content_json" \
               '.value += [ { "@search.action":"mergeOrUpload", id:$id, path:$path, layer:$layer, project:$project, content:$content } ]' \
               docs.json > "$tmp"
            mv "$tmp" docs.json

            echo "OK: added $path -> id=$id, layer=$layer"
            ok=$((ok+1))
          done

          echo "SUMMARY ok=$ok fail=$fail"
          if [ $ok -eq 0 ]; then
            echo "ERROR: docs.json has no items. Check branch name, repo name/GUID, or paths."
            cat docs.json
            exit 2
          fi

          echo "Preview docs.json:"
          jq '.value | length as $n | {count:$n, ids: [.[].id]}' docs.json

      - name: Upload docs.json artifact (for debugging)
        uses: actions/upload-artifact@v4
        with:
          name: docs-json
          path: docs.json

      # =========================
      # Push to Azure AI Search
      # =========================
      - name: Push docs to Azure AI Search
        shell: bash
        env:
          SEARCH_ENDPOINT: ${{ secrets.AZURE_SEARCH_ENDPOINT }}   # e.g. https://search-kemibrug.search.windows.net
          SEARCH_INDEX:    ${{ secrets.AZURE_SEARCH_INDEX }}      # e.g. kemibrug-rules
          SEARCH_KEY:      ${{ secrets.AZURE_SEARCH_ADMIN_KEY }}  # ADMIN key (not query key)
        run: |
          set -euo pipefail
          echo "Uploading to $SEARCH_ENDPOINT / index=$SEARCH_INDEX"
          http=$(curl -sS -o upload_resp.json -w "%{http_code}" -X POST \
            -H "Content-Type: application/json" \
            -H "api-key: ${SEARCH_KEY}" \
            --data @docs.json \
            "${SEARCH_ENDPOINT}/indexes/${SEARCH_INDEX}/docs/index?api-version=2023-11-01")
          echo "HTTP $http"
          echo "Response:"
          cat upload_resp.json
          # basic sanity: ensure at least 1 item processed
          jq '.value | length' upload_resp.json | grep -q '^[1-9]' || { echo "No docs indexed"; exit 2; }

      # =========================
      # Build & Deploy Functions
      # =========================
      - name: Build
        shell: pwsh
        run: |
          pushd './${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}'
          dotnet build --configuration Release --output ./output
          popd

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZUREAPPSERVICE_CLIENTID_CC61583FBBEC4600B796FAECBE66F119 }}
          tenant-id: ${{ secrets.AZUREAPPSERVICE_TENANTID_4FAB11EB01304BE09563B7410BD1E837 }}
          subscription-id: ${{ secrets.AZUREAPPSERVICE_SUBSCRIPTIONID_BE4AA3B5668B4EFD94873CB496000E0A }}

      - name: Configure app settings
        uses: azure/CLI@v1
        with:
          inlineScript: |
            az functionapp config appsettings set \
              --name kemibrug-ai-assistant \
              --resource-group rg-diplomprojekt-ai \
              --settings \
                AzureDevOpsPAT='${{ secrets.AZURE_DEVOPS_PAT }}' \
                AzureDevOpsOrgUrl='${{ secrets.AZURE_DEVOPS_ORG_URL }}' \
                AzureDevOpsProject='${{ secrets.AZUREDEVOPSPROJECT }}' \
                AzureDevOpsRepositoryName='${{ secrets.AZUREDEVOPSREPOSITORYNAME }}' \
                AzureOpenAIEndpoint='${{ secrets.AZURE_OPENAI_ENDPOINT }}' \
                AzureOpenAIApiKey='${{ secrets.AZURE_OPENAI_APIKEY }}' \
                AzureSearchEndpoint='${{ secrets.AZURE_SEARCH_ENDPOINT }}' \
                AzureSearchIndex='${{ secrets.AZURE_SEARCH_INDEX }}' \
                AzureSearchApiKey='${{ secrets.AZURE_SEARCH_ADMIN_KEY }}'

      - name: Deploy to Azure Functions
        uses: Azure/functions-action@v1
        with:
          app-name: 'kemibrug-ai-assistant'
          slot-name: 'Production'
          package: '${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}/output'
