name: Build and deploy dotnet core app to Azure Function App - kemibrug-ai-assistant

on:
  push:
    branches: [ master ]
  workflow_dispatch:

env:
  AZURE_FUNCTIONAPP_PACKAGE_PATH: '.'
  DOTNET_VERSION: '8.0.x'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET ${{ env.DOTNET_VERSION }}
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Tools (jq, python)
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update -y >/dev/null
          sudo apt-get install -y jq python3 >/dev/null

      # =======================
      # Resolve ADO project/repo
      # =======================
      - name: Resolve Azure DevOps ProjectId and RepoId (robust)
        id: ado
        shell: bash
        env:
          ORG_URL: ${{ secrets.AZURE_DEVOPS_ORG_URL }}        # e.g. https://dev.azure.com/Custom-Web-Solutions
          PAT:     ${{ secrets.AZURE_DEVOPS_PAT }}
          IN_PROJ: ${{ secrets.AZUREDEVOPSPROJECT }}          # projektets NAVN eller ID
          IN_REPO: ${{ secrets.AZUREDEVOPSREPOSITORYNAME }}   # repo NAVN eller ID
        run: |
          set -euo pipefail

          if [ -z "${ORG_URL:-}" ] || [ -z "${PAT:-}" ] || [ -z "${IN_PROJ:-}" ] || [ -z "${IN_REPO:-}" ]; then
            echo "::error::Missing one or more ADO secrets (ORG_URL, PAT, AZUREDEVOPSPROJECT, AZUREDEVOPSREPOSITORYNAME)."
            exit 3
          fi

          # Helper: case-insensitive cmp in jq
          jq_ci_match='( ( .name // "" ), ( .id // "" ) | ascii_downcase ) as $x | ($x == ($needle|ascii_downcase))'

          # Fetch projects
          PROJ_URL="${ORG_URL%/}/_apis/projects?api-version=7.1-preview.4"
          echo "GET $PROJ_URL"
          PROJ_JSON=$(curl -sS -L --fail-with-body -u :$PAT "$PROJ_URL")
          export needle="$IN_PROJ"
          PROJECT_ID=$(jq -r --arg needle "$IN_PROJ" '
            .value[] | select( ( .name|ascii_downcase == ($needle|ascii_downcase) ) or ( .id|ascii_downcase == ($needle|ascii_downcase) ) ) | .id
          ' <<<"$PROJ_JSON" | head -n1)

          if [ -z "${PROJECT_ID:-}" ] || [ "$PROJECT_ID" = "null" ]; then
            echo "::error::Could not resolve ProjectId from '$IN_PROJ'."
            echo "Projects available:" 
            jq -r '.value[] | "\(.name)  (\(.id))"' <<<"$PROJ_JSON" || true
            exit 3
          fi
          echo "Resolved PROJECT_ID=$PROJECT_ID"

          # Fetch repos for that project
          REPO_URL="${ORG_URL%/}/${PROJECT_ID}/_apis/git/repositories?api-version=7.1-preview.1"
          echo "GET $REPO_URL"
          REPO_JSON=$(curl -sS -L --fail-with-body -u :$PAT "$REPO_URL")
          REPO_ID=$(jq -r --arg needle "$IN_REPO" '
            .value[] | select( ( .name|ascii_downcase == ($needle|ascii_downcase) ) or ( .id|ascii_downcase == ($needle|ascii_downcase) ) ) | .id
          ' <<<"$REPO_JSON" | head -n1)

          if [ -z "${REPO_ID:-}" ] || [ "$REPO_ID" = "null" ]; then
            echo "::error::Could not resolve RepoId from '$IN_REPO'."
            echo "Repos available:"
            jq -r '.value[] | "\(.name)  (\(.id))"' <<<"$REPO_JSON" || true
            exit 3
          fi
          echo "Resolved REPO_ID=$REPO_ID"

          echo "PROJECT_ID=$PROJECT_ID"   >> $GITHUB_ENV
          echo "REPO_ID=$REPO_ID"         >> $GITHUB_ENV

      # =======================
      # Build docs.json from READMEs (raw mode)
      # =======================
      - name: Build docs.json from READMEs (raw text mode)
        shell: bash
        env:
          ORG_URL:    ${{ secrets.AZURE_DEVOPS_ORG_URL }}
          PAT:        ${{ secrets.AZURE_DEVOPS_PAT }}
          PROJECT_ID: ${{ env.PROJECT_ID }}
          REPO_ID:    ${{ env.REPO_ID }}
        run: |
          set -euo pipefail

          # URL-encode helper (reads from stdin)
          urlencode() {
            python3 - <<'PY'
            import sys, urllib.parse
            print(urllib.parse.quote(sys.stdin.read().strip(), safe=""))
            PY
          }

          # README-mapping (udvid hvis du tilfÃ¸jer flere)
          declare -A FILES
          FILES["/src/KemibrugV2.Application/README.md"]="Application"
          FILES["/src/KemibrugV2.Core/README.md"]="Core"
          FILES["/src/KemibrugV2.Infrastructure/README.md"]="Infrastructure"
          FILES["/src/KemibrugV2.WebApiServer/README.md"]="WebApiServer"

          echo "[" > docs.json
          first=1
          added=0
          for path in "${!FILES[@]}"; do
            layer="${FILES[$path]}"
            enc_path=$(printf "%s" "$path" | urlencode)
            url="${ORG_URL%/}/${PROJECT_ID}/_apis/git/repositories/${REPO_ID}/items?path=${enc_path}&download=true&api-version=7.1-preview.1"
            echo "GET $path"
            tmp=$(mktemp)
            code=$(curl -sS -L --fail-with-body -H "Accept: text/plain" -u :$PAT -w "%{http_code}" -o "$tmp" "$url" || true)
            echo "HTTP $code"
            if [ "$code" != "200" ]; then
              echo "WARN: could not fetch $path (HTTP $code)"; head -c 200 "$tmp" || true; echo
              rm -f "$tmp"
              continue
            fi

            # JSON-escape indholdet
            content_json=$(jq -Rs . < "$tmp")
            rm -f "$tmp"

            id=$(echo "$path" | sed 's/[^a-zA-Z0-9._-]/_/g')

            entry=$(jq -n \
              --arg id "$id" \
              --arg path "$path" \
              --arg layer "$layer" \
              --argjson content "$content_json" \
              '{ "@search.action":"mergeOrUpload", id:$id, path:$path, layer:$layer, content:$content }')

            if [ $first -eq 0 ]; then echo "," >> docs.json; fi
            echo "$entry" >> docs.json
            first=0
            added=$((added+1))
          done
          echo "]" >> docs.json

          if [ "$added" -eq 0 ]; then
            echo "::error::No README files added to docs.json; fix IDs/paths/PAT."
            exit 2
          fi

          echo "SUMMARY ok=$added"
          jq '.[].id' docs.json || true

      - name: Upload docs.json artifact (debug)
        uses: actions/upload-artifact@v4
        with:
          name: docs-json
          path: docs.json

      # =======================
      # Push docs to Azure AI Search
      # =======================
      - name: Push docs to Azure AI Search
        if: always()
        shell: bash
        env:
          SEARCH_ENDPOINT: ${{ secrets.AZURE_SEARCH_ENDPOINT }}   # e.g. https://search-kemibrug.search.windows.net
          SEARCH_INDEX:    ${{ secrets.AZURE_SEARCH_INDEX }}      # e.g. kemibrug-rules
          SEARCH_KEY:      ${{ secrets.AZURE_SEARCH_ADMIN_KEY }}
        run: |
          set -euo pipefail
          if [ ! -s docs.json ]; then
            echo "::warning::docs.json missing or empty; skipping AI Search push."
            exit 0
          fi
          curl -sS -X POST \
            -H "Content-Type: application/json" \
            -H "api-key: ${SEARCH_KEY}" \
            --data @docs.json \
            "${SEARCH_ENDPOINT%/}/indexes/${SEARCH_INDEX}/docs/index?api-version=2023-11-01" \
            | jq -r '.'
          echo "Uploaded README docs to Azure AI Search."

      # =======================
      # Build & Deploy Azure Functions
      # =======================
      - name: Build Function App
        shell: bash
        run: |
          set -euo pipefail
          pushd './${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}'
          dotnet build --configuration Release --output ./output
          popd

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZUREAPPSERVICE_CLIENTID_CC61583FBBEC4600B796FAECBE66F119 }}
          tenant-id: ${{ secrets.AZUREAPPSERVICE_TENANTID_4FAB11EB01304BE09563B7410BD1E837 }}
          subscription-id: ${{ secrets.AZUREAPPSERVICE_SUBSCRIPTIONID_BE4AA3B5668B4EFD94873CB496000E0A }}

      - name: Configure app settings
        uses: azure/CLI@v1
        with:
          inlineScript: |
            az functionapp config appsettings set \
              --name kemibrug-ai-assistant \
              --resource-group rg-diplomprojekt-ai \
              --settings \
                AzureDevOpsPAT='${{ secrets.AZURE_DEVOPS_PAT }}' \
                AzureDevOpsOrgUrl='${{ secrets.AZURE_DEVOPS_ORG_URL }}' \
                AzureDevOpsProject='${{ secrets.AZUREDEVOPSPROJECT }}' \
                AzureDevOpsRepositoryName='${{ secrets.AZUREDEVOPSREPOSITORYNAME }}' \
                AzureOpenAIEndpoint='${{ secrets.AZURE_OPENAI_ENDPOINT }}' \
                AzureOpenAIApiKey='${{ secrets.AZURE_OPENAI_APIKEY }}' \
                AzureSearchEndpoint='${{ secrets.AZURE_SEARCH_ENDPOINT }}' \
                AzureSearchIndex='${{ secrets.AZURE_SEARCH_INDEX }}' \
                AzureSearchApiKey='${{ secrets.AZURE_SEARCH_ADMIN_KEY }}' \
                AnalysisSystemPromptV2='${{ secrets.ANALYSIS_SYSTEM_PROMPT_V2 }}'

      - name: Deploy to Azure Functions
        uses: Azure/functions-action@v1
        id: fa
        with:
          app-name: 'kemibrug-ai-assistant'
          slot-name: 'Production'
          package: '${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}/output'
