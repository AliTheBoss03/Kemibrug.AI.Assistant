name: Build and deploy dotnet core app to Azure Function App - kemibrug-ai-assistant

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  AZURE_FUNCTIONAPP_PACKAGE_PATH: '.'
  DOTNET_VERSION: '8.0.x'
  BRANCH: 'master'   # change to 'main' if needed

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Ensure tools
        shell: bash
        run: |
          set -e
          sudo apt-get update -y
          sudo apt-get install -y jq >/dev/null

      # ---------- Resolve Azure DevOps repo ID (accept name or GUID) ----------
      - name: Resolve ADO repo ID
        id: ado
        shell: bash
        env:
          ORG_URL:  ${{ secrets.AZURE_DEVOPS_ORG_URL }}       # e.g. https://dev.azure.com/Custom-Web-Solutions
          PROJECT:  ${{ secrets.AZUREDEVOPSPROJECT }}         # exact project name
          REPO_IN:  ${{ secrets.AZUREDEVOPSREPOSITORYNAME }}  # repo name OR GUID
          PAT:      ${{ secrets.AZURE_DEVOPS_PAT }}
        run: |
          set -euo pipefail
          echo "ORG_URL=$ORG_URL"
          echo "PROJECT=$PROJECT"
          echo "REPO_IN=$REPO_IN"

          if [ -z "${ORG_URL:-}" ] || [ -z "${PROJECT:-}" ] || [ -z "${REPO_IN:-}" ] || [ -z "${PAT:-}" ]; then
            echo "ERROR: Missing ORG_URL/PROJECT/REPO_IN/PAT"
            exit 3
          fi

          # If REPO_IN looks like a GUID, use as-is
          if [[ "$REPO_IN" =~ ^[0-9a-fA-F-]{36}$ ]]; then
            REPO_ID="$REPO_IN"
            echo "Using provided repo GUID: $REPO_ID"
          else
            # Look up by name to get ID
            list_url="${ORG_URL%/}/${PROJECT}/_apis/git/repositories?api-version=7.1-preview.1"
            echo "GET $list_url"
            resp="$(curl -sS -u :$PAT "$list_url")" || { echo "ERROR: curl failed listing repos"; exit 3; }
            # fail early if not JSON
            echo "$resp" | jq -e . >/dev/null || { echo "ERROR: Non-JSON response listing repos"; echo "$resp"; exit 3; }
            REPO_ID="$(echo "$resp" | jq -r --arg name "$REPO_IN" '.value[] | select(.name==$name) | .id' | head -n1)"
            if [ -z "$REPO_ID" ] || [ "$REPO_ID" = "null" ]; then
              echo "ERROR: Could not find repository named '$REPO_IN' in project '$PROJECT'."
              echo "Available repos:" 
              echo "$resp" | jq -r '.value[] | "\(.name)  \(.id)"'
              exit 3
            fi
            echo "Resolved repo '$REPO_IN' -> $REPO_ID"
          fi

          echo "repo_id=$REPO_ID" >> "$GITHUB_OUTPUT"

      # ---------- Fetch four README.md files as raw bytes (octet-stream) and build docs.json ----------
      - name: Build docs.json from ADO READMEs
        shell: bash
        env:
          ORG_URL:   ${{ secrets.AZURE_DEVOPS_ORG_URL }}
          PROJECT:   ${{ secrets.AZUREDEVOPSPROJECT }}
          REPO_ID:   ${{ steps.ado.outputs.repo_id }}
          PAT:       ${{ secrets.AZURE_DEVOPS_PAT }}
          BRANCH:    ${{ env.BRANCH }}
        run: |
          set -euo pipefail

          declare -A FILES
          FILES["/src/KemibrugV2.Application/README.md"]="Application"
          FILES["/src/KemibrugV2.Core/README.md"]="Core"
          FILES["/src/KemibrugV2.Infrastructure/README.md"]="Infrastructure"
          FILES["/src/KemibrugV2.WebApiServer/README.md"]="WebApiServer"

          base="${ORG_URL%/}/${PROJECT}/_apis/git/repositories/${REPO_ID}/items"

          # small retry helper
          fetch_file() {
            local path="$1"
            local tries=3
            local tmp="$(mktemp)"
            local code
            for i in $(seq 1 $tries); do
              code=$(curl -sS -L -u :$PAT -w "%{http_code}" -o "$tmp" \
                -H "Accept: application/octet-stream" \
                -G \
                --data-urlencode "path=${path}" \
                --data-urlencode "versionDescriptor.version=${BRANCH}" \
                --data-urlencode "api-version=7.1-preview.1" \
                "$base" || true)
              echo "GET ${base}?path=<encoded>&versionDescriptor.version=${BRANCH} -> HTTP ${code} for ${path}"
              if [ "$code" = "200" ]; then
                cat "$tmp"
                rm -f "$tmp"
                return 0
              fi
              sleep 1
            done
            rm -f "$tmp"
            return 22
          }

          echo "[" > docs.json
          first=1
          added=0

          for p in "${!FILES[@]}"; do
            layer="${FILES[$p]}"
            content="$(fetch_file "$p" || true)"
            if [ -z "$content" ]; then
              echo "WARN: Could not fetch $p"
              continue
            fi

            # base64 encode (one line)
            b64="$(printf "%s" "$content" | base64 -w0)"
            id="$(echo "$p" | sed 's/[^a-zA-Z0-9._-]/_/g')"

            entry=$(jq -n \
              --arg id "$id" \
              --arg path "$p" \
              --arg layer "$layer" \
              --arg project "KemibrugV2" \
              --arg content_b64 "$b64" \
              '{ "@search.action":"mergeOrUpload",
                 id:$id, path:$path, layer:$layer, project:$project,
                 encoding:"base64", content_b64:$content_b64 }')

            if [ $first -eq 0 ]; then echo "," >> docs.json; fi
            echo "$entry" >> docs.json
            first=0
            added=$((added+1))
            echo "OK: added $p ($layer)"
          done

          echo "]" >> docs.json
          if [ "$added" -eq 0 ]; then
            echo "ERROR: docs.json has no items. Check branch, repo ID, or paths exist on that branch."
            exit 2
          fi
          echo "Built docs.json with $added item(s)."

      - name: Upload docs.json artifact (debug)
        uses: actions/upload-artifact@v4
        with:
          name: docs-json
          path: docs.json

      # ---------- Push docs to Azure AI Search ----------
      - name: Push docs to Azure AI Search
        shell: bash
        env:
          SEARCH_ENDPOINT: ${{ secrets.AZURE_SEARCH_ENDPOINT }}   # https://<name>.search.windows.net
          SEARCH_INDEX:    ${{ secrets.AZURE_SEARCH_INDEX }}      # kemibrug-rules
          SEARCH_KEY:      ${{ secrets.AZURE_SEARCH_ADMIN_KEY }}
        run: |
          set -euo pipefail
          if [ ! -s docs.json ]; then
            echo "WARN: docs.json missing or empty; skipping AI Search push."
            exit 0
          fi
          curl -sS -X POST \
            -H "Content-Type: application/json" \
            -H "api-key: ${SEARCH_KEY}" \
            --data @docs.json \
            "${SEARCH_ENDPOINT%/}/indexes/${SEARCH_INDEX}/docs/index?api-version=2023-11-01"
          echo "Uploaded README docs to Azure AI Search."

      # ---------- Build & deploy Functions ----------
      - name: Build Functions
        shell: bash
        run: |
          set -e
          pushd './${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}'
          dotnet build --configuration Release --output ./output
          popd

      - name: Azure login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZUREAPPSERVICE_CLIENTID_CC61583FBBEC4600B796FAECBE66F119 }}
          tenant-id: ${{ secrets.AZUREAPPSERVICE_TENANTID_4FAB11EB01304BE09563B7410BD1E837 }}
          subscription-id: ${{ secrets.AZUREAPPSERVICE_SUBSCRIPTIONID_BE4AA3B5668B4EFD94873CB496000E0A }}

      - name: Configure app settings
        uses: azure/CLI@v1
        with:
          inlineScript: |
            az functionapp config appsettings set \
              --name kemibrug-ai-assistant \
              --resource-group rg-diplomprojekt-ai \
              --settings \
                AzureDevOpsPAT='${{ secrets.AZURE_DEVOPS_PAT }}' \
                AzureDevOpsOrgUrl='${{ secrets.AZURE_DEVOPS_ORG_URL }}' \
                AzureDevOpsProject='${{ secrets.AZUREDEVOPSPROJECT }}' \
                AzureDevOpsRepositoryName='${{ secrets.AZUREDEVOPSREPOSITORYNAME }}' \
                AzureOpenAIEndpoint='${{ secrets.AZURE_OPENAI_ENDPOINT }}' \
                AzureOpenAIApiKey='${{ secrets.AZURE_OPENAI_APIKEY }}' \
                AzureSearchEndpoint='${{ secrets.AZURE_SEARCH_ENDPOINT }}' \
                AzureSearchIndex='${{ secrets.AZURE_SEARCH_INDEX }}' \
                AzureSearchApiKey='${{ secrets.AZURE_SEARCH_ADMIN_KEY }}' \
                AnalysisSystemPromptV2='${{ secrets.ANALYSIS_SYSTEM_PROMPT_V2 }}'

      - name: Deploy to Azure Functions
        uses: Azure/functions-action@v1
        with:
          app-name: 'kemibrug-ai-assistant'
          slot-name: 'Production'
          package: '${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}/output'
